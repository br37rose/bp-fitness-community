package eventscheduler

import (
	"context"
	"crypto/rand"
	"fmt"
	"log"
	"log/slog"
	mrand "math/rand"
	"os"
	"sync"
	"time"

	"github.com/pkg/errors"
	redis "github.com/redis/go-redis/v9"

	"github.com/go-co-op/gocron/v2"
)

var (
	ErrNonLeader = errors.New("the elector is not leader")
	ErrClosed    = errors.New("the elector is already closed")
	ErrPingEtcd  = errors.New("ping etcd server timeout")
)

var _ gocron.Elector = (*Elector)(nil)

type Elector struct {
	ctx    context.Context
	cancel context.CancelFunc

	// config  clientv3.Config
	// options []concurrency.SessionOption
	// client  *clientv3.Client
	id     string
	logger *slog.Logger
	redis  redis.UniversalClient

	mu     sync.RWMutex
	closed bool
}

func NewElector(loggerp *slog.Logger, redisClient redis.UniversalClient) *Elector {
	return &Elector{
		logger: loggerp,
		id:     getID(),
		redis:  redisClient,
	}
}

// https://github.com/go-co-op/gocron-etcd-elector/blob/main/elector.go#L221C1-L229C2
func getID() string {
	hostname, _ := os.Hostname()
	bs := make([]byte, 10)
	_, err := rand.Read(bs)
	if err != nil {
		return fmt.Sprintf("%s-%d", hostname, mrand.Int63())
	}
	return fmt.Sprintf("%s-%x", hostname, bs)
}

func (e *Elector) IsLeader(_ context.Context) error {
	e.mu.RLock()
	defer e.mu.RUnlock()

	leaderID, err := e.redis.Get(context.Background(), "elector_leader_id").Result()
	if err != nil || leaderID == "" {
		// Elect ourselves the leader for the next 5 minutes.
		err := e.redis.Set(context.Background(), "elector_leader_id", e.id, 5*time.Minute).Err()
		if err != nil {
			log.Fatalf("Failed to set key %s: %v", "elector_leader_id", err)
		}
		return nil
	}

	if e.id == leaderID {
		e.logger.Debug(fmt.Sprintf("host `%v` is elected leader", e.id))
		return nil
	}
	e.logger.Debug(fmt.Sprintf("host `%v` is not elected leader", e.id))
	return ErrNonLeader
}

//
// func (e *Elector) electLeader() error {
// 	// STEP 1:
// 	// Look in redis to see if an elected leader was set.
// 	currentLeaderID, err := e.redis.Get(context.Background(), "elector_leader_id").Result()
//
// 	// STEP 2:
// 	// If no leader was set then an error gets generated by redis. Therefore
// 	// we will elect ourselves as the leader.
// 	if err != nil || currentLeaderID == "" {
// 		myID := getID()
//
// 		// If we get an error that means there is value.
// 		e.setLeader(myID)
//
// 		// Elect ourselves the leader for the next 5 minutes.
// 		err := e.redis.Set(context.Background(), "elector_leader_id", myID, 5*time.Minute).Err()
// 		if err != nil {
// 			log.Fatalf("Failed to set key %s: %v", "elector_leader_id", err)
// 		}
//
// 		// For debugging purposes only.
// 		fmt.Printf("SET %s -> %s\n", "elector_leader_id", myID)
// 	} else {
// 		// STEP 3:
// 		// If a value was returned then check to see if it us, if not
// 		// keep record of current leader.
// 		fmt.Printf("GET %s -> %s\n", "elector_leader_id", currentLeaderID)
// 		if currentLeaderID != e.leaderID {
// 			e.unsetLeader(currentLeaderID)
// 		}
// 	}
// 	return nil
// }

// Start Start the election.
// This method will keep trying the election. When the election is successful, set isleader to true.
// If it fails, the election directory will be monitored until the election is successful.
// The parameter electionPath is used to specify the etcd directory for the operation.
func (e *Elector) Start() error {
	if e.closed {
		return ErrClosed
	}

	// ALGORITHM
	// Set ourselves as leader. If there are multiple instances set then the
	// last saved will become leader.
	err := e.redis.Set(context.Background(), "elector_leader_id", e.id, 0).Err()
	if err != nil {
		log.Fatalf("Failed to set key %s: %v", "elector_leader_id", err)
	}

	// For debugging purposes only.
	fmt.Printf("SET %s -> %s\n", "elector_leader_id", e.id)

	return nil
}

func (e *Elector) Stop() error {
	e.mu.Lock()
	defer e.mu.Unlock()

	if e.closed {
		return nil
	}

	e.closed = true
	return nil
}
